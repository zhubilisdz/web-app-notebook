结构化技术需求文档：AI Native 记事本
1. 项目/功能概述 (Overview)
开发一个单用户、桌面优先的 Web 记事本应用。该应用的核心特色是深度集成了 AI 功能，包括文本润色、自动生成标签和基于内容理解的语义搜索，旨在打造一个智能化的个人知识库。

2. 核心功能点 (Core Features)
笔记管理 (CRUD):
创建新笔记。
查看和编辑笔记。
删除笔记。
所有笔记都将持久化存储在服务器上。
AI 文本处理:
润色与改写: 用户可以选中笔记中的任意文本，通过按钮调用 AI 进行润色、缩写、扩写或改变语气。
自动标签: 在创建或更新笔记后，系统自动调用 AI 分析笔记内容，并为其生成 3-5 个相关的标签（Tags）用于分类。
AI 语义搜索:
提供一个搜索框，用户可以用自然语言（如一个问题或一个模糊的概念）进行搜索，系统能理解其意图，并返回内容最相关的笔记，而不仅仅是关键词匹配。
界面布局:
采用经典的三栏式布局：[笔记列表] | [笔记编辑器] | [AI 与搜索面板]。
安全性:
Kimi API Key 将安全地存储在后端服务器，不会暴露给前端。
3. 技术规格 (Technical Specifications)
前端 (Frontend)
页面/组件 (Pages/Components):
App.vue: 应用主容器，负责整体布局。
NoteList.vue (左栏):
显示所有笔记的标题和摘要列表。
响应用户点击，通知主应用切换当前正在编辑的笔记。
包含“创建新笔记”按钮。
NoteEditor.vue (中栏):
一个文本编辑区域，用于输入和显示笔记的标题和正文。
包含“删除笔记”按钮。
包含 AI 功能触发按钮，如“润色”、“改写”等。这些按钮在用户选中文本后激活。
SidePanel.vue (右栏):
顶部是“语义搜索”输入框和搜索结果区域。
下方显示当前笔记的自动生成标签。
用户流程 (User Flow):
加载应用: 打开页面，应用向后端请求所有笔记列表，并展示在左栏。默认选中第一篇或最新的笔记，内容显示在中间编辑器。
创建笔记: 点击“创建新笔记”，左侧列表出现一个“无标题笔记”条目并高亮，中间编辑器清空以供输入。
编辑笔记: 用户在编辑器中输入内容。可以实现“自动保存”：当用户停止输入 2-3 秒后，前端自动将笔记内容发送到后端进行更新。
AI 润色: 用户在编辑器中选中文本，点击“润色”按钮。前端将选中的文本发送给后端，并用一个加载动画（Loading indicator）暂时替代按钮。后端返回处理后的文本后，前端用新文本替换掉原文。
语义搜索: 用户在右栏搜索框输入问题或关键词并回车。前端将搜索词发送给后端，后端返回一个排序后的相关笔记列表。前端更新左栏的笔记列表以显示这些搜索结果。
数据交互 (Data Interaction):
向后端请求数据(Requesting data):
GET /api/notes - 获取所有笔记的列表（可只含 id, title, a short snippet）。
GET /api/notes/:id - 获取某一篇笔记的完整内容。
GET /api/search?q=... - 发送搜索请求，q 是搜索内容。
向后端发送数据(Sending data):
POST /api/notes - 创建新笔记。请求体(Body): { "title": "...", "content": "..." }。
PUT /api/notes/:id - 更新笔记。请求体(Body): { "title": "...", "content": "..." }。
DELETE /api/notes/:id - 删除笔记。
POST /api/ai/rewrite - 请求 AI 润色。请求体: { "text": "要润色的文字" }。
后端 (Backend)
API 接口 (API Endpoints):
GET /api/notes: 查询数据库，返回所有笔记的元信息数组 [{ id, title, created_at, tags }]。
GET /api/notes/:id: 查询数据库，返回指定 id 笔记的完整信息 { id, title, content, tags, ... }。
POST /api/notes: 接收 { title, content }，在数据库中创建新记录。关键： 创建成功后，异步调用 Kimi API 为 content 生成标签和内容嵌入向量（用于语义搜索），并存入数据库。返回新创建的笔记对象。
PUT /api/notes/:id: 接收 { title, content }，更新数据库中对应记录。关键： 更新成功后，同样重新生成标签和嵌入向量。
DELETE /api/notes/:id: 删除数据库中对应的笔记及其关联数据。
POST /api/ai/rewrite: 接收 { text }。这是一个代理接口，它会在内部调用 Kimi API（使用服务器上存储的 Key），并带上合适的指令（Prompt），例如“请帮我润色以下这段文字：...”。然后将 Kimi 的返回结果发送给前端。
GET /api/search: 接收查询参数 q。关键：
调用 Kimi API 将查询词 q 也转换成一个嵌入向量。
使用这个向量在数据库中进行向量相似度搜索。
返回与查询向量最相似的笔记列表。
数据模型 (Data Models):
Note (笔记表):
id: 主键 (Primary Key), Integer
title: 标题, Text
content: 笔记正文, Text
embedding: 用于语义搜索的向量 (Vector Type)。这是一个数字数组，代表了笔记内容的语义信息。
created_at: 创建时间, Timestamp
updated_at: 更新时间, Timestamp
Tag (标签表):
id: 主键, Integer
name: 标签名, Text, Unique
Note_Tag (笔记-标签关联表): (用于实现多对多关系)
note_id: 外键 (Foreign Key) 关联到 Note 表
tag_id: 外键关联到 Tag 表
4. 技术栈建议 (Tech Stack Suggestion)
考虑到你是初学者且项目为单人使用，我推荐一个轻量且强大的组合：

前端: Vue.js - 学习曲线平缓，社区活跃，单文件组件的组织方式对新手很友好。
后端: Python + Flask - Python 是 AI 领域的首选语言，有大量现成的库可以调用 Kimi API。Flask 是一个微框架，代码简洁，没有太多复杂的概念，非常适合启动小型项目。
数据库: SQLite - 这是一个无服务器的、基于文件的数据库。你不需要安装和配置数据库服务器，非常方便。对于语义搜索，我们可以使用 sqlite-vss 这个扩展，它能让 SQLite 支持向量搜索。
AI 服务: Kimi API - 按你的要求，用于文本生成、标签提取和内容嵌入。
5. 开发步骤建议 (Development Steps)
我为你把整个项目拆解成了可以一步步执行的小任务，你可以按顺序完成，每完成一步都会有满满的成就感。

环境搭建:
安装 Node.js (用于前端), Python (用于后端)。
创建项目文件夹，内部包含 frontend 和 backend 两个子文件夹。
后端基础 (Backend Foundation):
在 backend 文件夹中，建立一个基础的 Flask 应用。
使用 SQLAlchemy (一个 Python 库) 定义 Note, Tag, Note_Tag 数据模型，并使用 SQLite 作为数据库。
运行命令，生成数据库文件。
核心 API 开发 (Backend CRUD):
实现笔记的增 (POST /api/notes)、删 (DELETE /api/notes/:id)、改 (PUT /api/notes/:id)、查 (GET /api/notes, GET /api/notes/:id) 的 API 接口。
在这一步，先不考虑 AI 功能。 可以使用 Postman 或 Insomnia 这类工具测试接口是否工作正常。
前端基础 (Frontend Foundation):
在 frontend 文件夹中，使用 Vue CLI 创建一个新的 Vue 项目。
搭建出三栏布局的静态页面，暂时用假数据填充。
前后端连接 (Connecting Frontend & Backend):
让前端 Vue 应用通过 axios (一个 HTTP 请求库) 调用后端的 GET /api/notes 接口，将获取到的真实笔记数据显示在左栏。
实现点击列表项加载笔记详情，以及创建和删除笔记的功能。
实现第一个 AI 功能 (Rewrite Proxy):
在后端，安全地配置你的 Kimi API Key（比如通过环境变量）。
创建 POST /api/ai/rewrite 接口，实现调用 Kimi API 的逻辑。
在前端，给编辑器加上“润色”按钮，并连接到这个新接口。
实现 AI 自动标签:
修改后端的 POST /api/notes 和 PUT /api/notes/:id 接口。在保存笔记到数据库后，增加调用 Kimi API 生成标签的逻辑，并将标签存入数据库。
在前端，将获取到的标签显示在右侧面板。
实现王牌功能 (Semantic Search):
这是最具挑战性也最酷的一步。
为你的 SQLite 安装并启用 sqlite-vss 扩展。
修改后端，当笔记被创建/更新时，调用 Kimi 的嵌入（Embedding）接口生成向量并存入 Note 表的 embedding 字段。
创建 GET /api/search 接口，实现查询向量化和数据库向量搜索的逻辑。
在前端连接搜索框到此接口，并展示搜索结果。
打磨与优化:
添加加载动画、错误提示等，提升用户体验。
优化编辑器的自动保存逻辑。
美化 UI 界面。
